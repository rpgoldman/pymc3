# Stubs for pymc3.backends.base (Python 3.7)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional, Iterable, Mapping, Iterator, Tuple, Union, Generic, TypeVar, Collection
#from pymc3 import _Point
import pymc3 as pm
from pymc3.backends import Backend
from numpy import ndarray

class TraceMap:
    def __getitem__(self, idx: Union[int,str,Tuple[str,slice]]) -> ndarray: ...
    def keys(self) -> Iterator[str]: ...

logger: Any

class BackendError(Exception): ...

class BaseTrace (Backend):
    supports_sampler_stats: bool = ...
    name: str = ...
    model: pm.Model = ...
    vars: Any = ...
    varnames: Any = ...
    fn: Any = ...
    var_shapes: Any = ...
    var_dtypes: Any = ...
    chain: Any = ...
    _is_base_setup: bool = ...
    sampler_vars: Any = ...
    _warnings: Any = ...
    def __init__(self,
                 name: str,
                 model: Optional[pm.Model] = ...,
                 vars: Optional[Any] = ...,
                 test_point: Optional[Any] = ...) -> None: ...
    def _add_warnings(self, warnings: Any) -> None: ...
    def _set_sampler_vars(self, sampler_vars: Any): ...
    def setup(self, draws: Any, chain: Any, sampler_vars: Optional[Any] = ...) -> None: ...
    def record(self, point: Any, sampler_states: Optional[Any] = ...) -> None: ...
    def close(self) -> None: ...
    def __getitem__(self, idx: Any): ...
    def __len__(self) -> int: ...
    def get_values(self, varname: Any, burn: int = ..., thin: int = ...) -> None: ...
    def get_sampler_stats(self, varname: Any, sampler_idx: Optional[Any] = ..., burn: int = ..., thin: int = ...): ...
    def _get_sampler_stats(self, varname: Any, sampler_idx: Any, burn: Any, thin: Any) -> None: ...
    def _slice(self, idx: Any) -> None: ...
    def point(self, idx: Any) -> None: ...
    @property
    def stat_names(self): ...

class MultiTrace(TraceMap):
    _straces: Any = ...
    _report: Any = ...
    def __init__(self, straces: Any) -> None: ...
    def __repr__(self): ...
    @property
    def nchains(self) -> int: ...
    @property
    def chains(self): ...
    @property
    def report(self): ...
#    def __getitem__(self, idx: Union[int,str,Tuple[str,slice]]) -> ndarray: ...
    def __getattr__(self, name: str) -> Any: ...
    def __len__(self) -> int: ...
    @property
    def varnames(self) -> Iterable[str]: ...
    @property
    def stat_names(self): ...
    def add_values(self, vals: Any, overwrite: bool = ...) -> None: ...
    def remove_values(self, name: Any) -> None: ...
    def get_values(self, varname: Any, burn: int = ..., thin: int = ..., combine: bool = ..., chains: Optional[Any] = ..., squeeze: bool = ...): ...
    def get_sampler_stats(self, varname: Any, burn: int = ..., thin: int = ..., combine: bool = ..., chains: Optional[Any] = ..., squeeze: bool = ...): ...
    def _slice(self, slice: Any): ...
    def point(self, idx: Any, chain: Optional[Any] = ...) -> pm._Point: ...
    def points(self, chains: Optional[Any] = ...): ...

def merge_traces(mtraces: Any): ...
def _squeeze_cat(results: Any, combine: Any, squeeze: Any): ...
