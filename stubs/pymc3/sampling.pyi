# Stubs for pymc3.sampling (Python 3.7)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.
# ... and then hand-edited.

from numpy import ndarray
from typing import Any, Optional, Union, List, Generator, Iterable, Dict, Tuple, Sequence
from .backends.base import MultiTrace
from .model import Model
from .step_methods import NUTS
from .backends import Backend
from .distributions import Distribution
from . import _Point, _Varname, _RandomSeed
import pymc3 as pm

optint = Optional[int]
optbool = Optional[bool]

# FIXME: give better definitions for these
_Samples = Dict[pm._Varname, ndarray]
StepFunction = Any


def iter_sample(draws: int,
                step: Any,
                start: Optional[Any] = ...,
                # backend, list (of varnames),
                # or MultiTrace (with prev. samples)
                trace: Union[MultiTrace, List[str], Backend] = ...,
                chain: int = ...,
                tune: Optional[int] = ...,
                model: Optional[Model] = ...,
                random_seed: Optional[_RandomSeed] = ...) -> \
    Generator[MultiTrace, None, None]: ...

class PopulationStepper:
    nchains: Any = ...
    is_parallelized: bool = ...
    _master_ends: Any = ...
    _processes: Any = ...
    _steppers: Any = ...
    def __init__(self, steppers: Any, parallelize: Any) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any): ...
    @staticmethod
    def _run_slave(c: Any, stepper_dumps: Any, slave_end: Any): ...
    def step(self, tune_stop: Any, population: Any): ...

def sample(draws: optint=500,
           # function or iterable of functions
           step: Optional[Union[StepFunction, Iterable[StepFunction]]]=None,
           init: Optional[str]=None,
           n_init: optint=None,
           # dict, or array of dict) â€“ Starting point in parameter space (or partial point)
           start: Optional[Union[Dict[Any, Any], Sequence[Dict[Any, Any]]]]=None,
           trace: Optional[Any]=None,  # backend, list, or MultiTrace
           chain_idx: optint=None,
           chains: optint=None,
           cores: optint=None,
           tune: optint=None,
           nuts_kwargs: Optional[Dict[str,Any]]=None,
           step_kwargs: Optional[Dict[str,Any]]=None,
           progressbar: optbool=None,
           model: Optional[Model]=None,
           random_seed: _RandomSeed=None,
           live_plot: optbool=None,
           discard_tuned_samples: optbool=None,
           live_plot_kwargs: Optional[Dict[str,Any]]=None,
           compute_convergence_checks: optbool=None,
           use_mmap: optbool=None,
           **kwargs) -> MultiTrace:  ...

def sample_posterior_predictive(trace: MultiTrace,
                                samples: Optional[int] = ...,
                                model: Optional[Model] = ...,
                                vars: Optional[Iterable[Distribution]] = ...,
                                size: Optional[int] = ...,
                                random_seed: Optional[_RandomSeed] = ...,
                                progressbar: bool = ...)\
    -> _Samples: ...
# deprecated
def sample_ppc(*args: Any, **kwargs: Any) -> Dict[pm._Varname, ndarray]: ...

def sample_posterior_predictive_w(traces: Union[List[MultiTrace],
                                                List[Dict[str,Any]],
                                                List[pm._Point]],
                                  samples: Optional[int] = ...,
                                  models: Optional[Union[Model,List[Model]]] = ...,
                                  # map from models to weights
                                  weights: Dict[Any, float] = ...,
                                  random_seed: Optional[_RandomSeed] = ...,
                                  progressbar: bool = ...) -> _Samples: ...
# deprecated
def sample_ppc_w(*args: Any, **kwargs: Any): ...

def sample_prior_predictive(samples: Optional[int] = ...,
                            model: Optional[Model] = ...,
                            vars: Optional[Iterable[pm._Varname]] = ...,
                            random_seed: Optional[_RandomSeed] = ...)\
    -> _Samples: ...

_InitMethod = str

def init_nuts(init: Optional[_InitMethod] = ...,
              chains: Optional[int] = ...,
              n_init: int = ...,
              model: Optional[Model] = ...,
              random_seed: Optional[_RandomSeed] = ...,
              progressbar: bool = ...,
              *kwargs: Any) -> Tuple[pm._Point, NUTS]: ...
