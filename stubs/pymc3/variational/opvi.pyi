# Stubs for pymc3.variational.opvi (Python 3.7)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional

class VariationalInferenceError(Exception): ...
class ExplicitInferenceError(VariationalInferenceError, TypeError): ...
class AEVBInferenceError(VariationalInferenceError, TypeError): ...
class ParametrizationError(VariationalInferenceError, ValueError): ...
class GroupError(VariationalInferenceError, TypeError): ...
class BatchedGroupError(GroupError): ...
class LocalGroupError(BatchedGroupError, AEVBInferenceError): ...

class ObjectiveUpdates: #(theano.OrderedUpdates):
    loss: Any = ...

class ObjectiveFunction:
    op: Any = ...
    tf: Any = ...
    def __init__(self, op: Any, tf: Any) -> None: ...
    obj_params: Any = ...
    test_params: Any = ...
    approx: Any = ...
    def updates(self, obj_n_mc: Optional[Any] = ..., tf_n_mc: Optional[Any] = ..., obj_optimizer: Any = ..., test_optimizer: Any = ..., more_obj_params: Optional[Any] = ..., more_tf_params: Optional[Any] = ..., more_updates: Optional[Any] = ..., more_replacements: Optional[Any] = ..., total_grad_norm_constraint: Optional[Any] = ...): ...
    def add_test_updates(self, updates: Any, tf_n_mc: Optional[Any] = ..., test_optimizer: Any = ..., more_tf_params: Optional[Any] = ..., more_replacements: Optional[Any] = ..., total_grad_norm_constraint: Optional[Any] = ...) -> None: ...
    def add_obj_updates(self, updates: Any, obj_n_mc: Optional[Any] = ..., obj_optimizer: Any = ..., more_obj_params: Optional[Any] = ..., more_replacements: Optional[Any] = ..., total_grad_norm_constraint: Optional[Any] = ...) -> None: ...
    def step_function(self, obj_n_mc: Optional[Any] = ..., tf_n_mc: Optional[Any] = ..., obj_optimizer: Any = ..., test_optimizer: Any = ..., more_obj_params: Optional[Any] = ..., more_tf_params: Optional[Any] = ..., more_updates: Optional[Any] = ..., more_replacements: Optional[Any] = ..., total_grad_norm_constraint: Optional[Any] = ..., score: bool = ..., fn_kwargs: Optional[Any] = ...): ...
    def score_function(self, sc_n_mc: Optional[Any] = ..., more_replacements: Optional[Any] = ..., fn_kwargs: Optional[Any] = ...): ...
    def __call__(self, nmc: Any, **kwargs: Any): ...

class Operator:
    has_test_function: bool = ...
    returns_loss: bool = ...
    require_logq: bool = ...
    objective_class: Any = ...
    supports_aevb: Any = ...
    T: Any = ...
    approx: Any = ...
    def __init__(self, approx: Any) -> None: ...
    inputs: Any = ...
    logp: Any = ...
    varlogp: Any = ...
    datalogp: Any = ...
    logq: Any = ...
    logp_norm: Any = ...
    varlogp_norm: Any = ...
    datalogp_norm: Any = ...
    logq_norm: Any = ...
    model: Any = ...
    def apply(self, f: Any) -> None: ...
    def __call__(self, f: Optional[Any] = ...): ...
    def __str__(self): ...

class TestFunction:
    _inited: bool = ...
    shared_params: Any = ...
    def __init__(self) -> None: ...
    @property
    def params(self): ...
    def __call__(self, z: Any) -> None: ...
    def setup(self, approx: Any) -> None: ...
    @classmethod
    def from_function(cls, f: Any): ...

class Group:
    shared_params: Any = ...
    symbolic_initial: Any = ...
    replacements: Any = ...
    input: Any = ...
    supports_batched: bool = ...
    has_logq: bool = ...
    initial_dist_name: str = ...
    initial_dist_map: float = ...
    __param_spec__: Any = ...
    short_name: str = ...
    alias_names: Any = ...
    __param_registry: Any = ...
    __name_registry: Any = ...
    @classmethod
    def register(cls, sbcls: Any): ...
    @classmethod
    def group_for_params(cls, params: Any): ...
    @classmethod
    def group_for_short_name(cls, name: Any): ...
    def __new__(cls, group: Optional[Any] = ..., vfam: Optional[Any] = ..., params: Optional[Any] = ..., *args: Any, **kwargs: Any): ...
    options: Any = ...
    _vfam: Any = ...
    _local: Any = ...
    _batched: Any = ...
    _rng: Any = ...
    model: Any = ...
    group: Any = ...
    user_params: Any = ...
    _user_params: Any = ...
    _kwargs: Any = ...
    def __init__(self, group: Any, vfam: Optional[Any] = ..., params: Optional[Any] = ..., random_seed: Optional[Any] = ..., model: Optional[Any] = ..., local: bool = ..., rowwise: bool = ..., options: Optional[Any] = ..., **kwargs: Any) -> None: ...
    # the following has inconsistent type signature.
    # @classmethod
    # def get_param_spec_for(cls, **kwargs: Any): ...
    def _check_user_params(self, **kwargs: Any): ...
    def _initial_type(self, name: Any): ...
    def _input_type(self, name: Any): ...
    ordering: Any = ...
    bij: Any = ...
    def __init_group__(self, group: Any) -> None: ...
    def _finalize_init(self) -> None: ...
    local: Any = ...
    batched: Any = ...
    @property
    def params_dict(self): ...
    @property
    def params(self): ...
    def _new_initial_shape(self, size: Any, dim: Any, more_replacements: Optional[Any] = ...): ...
    def bdim(self): ...
    def ndim(self): ...
    @property
    def ddim(self): ...
    def _new_initial(self, size: Any, deterministic: Any, more_replacements: Optional[Any] = ...): ...
    def symbolic_random(self) -> None: ...
    def symbolic_random2d(self): ...
    def set_size_and_deterministic(self, node: Any, s: Any, d: Any, more_replacements: Optional[Any] = ...): ...
    def to_flat_input(self, node: Any): ...
    def symbolic_sample_over_posterior(self, node: Any): ...
    def symbolic_single_sample(self, node: Any): ...
    def make_size_and_deterministic_replacements(self, s: Any, d: Any, more_replacements: Optional[Any] = ...): ...
    def symbolic_normalizing_constant(self): ...
    def symbolic_logq_not_scaled(self) -> None: ...
    def symbolic_logq(self): ...
    def logq(self): ...
    def logq_norm(self): ...
    def __str__(self): ...
    def std(self) -> None: ...
    def cov(self) -> None: ...
    def mean(self) -> None: ...

class Approximation:
    _scale_cost_to_minibatch: Any = ...
    groups: Any = ...
    model: Any = ...
    def __init__(self, groups: Any, model: Optional[Any] = ...) -> None: ...
    @property
    def has_logq(self): ...
    def collect(self, item: Any, part: str = ...): ...
    inputs: Any = ...
    symbolic_randoms: Any = ...
    @property
    def scale_cost_to_minibatch(self): ...
    @scale_cost_to_minibatch.setter
    def scale_cost_to_minibatch(self, value: Any) -> None: ...
    def symbolic_normalizing_constant(self): ...
    def symbolic_logq(self): ...
    def logq(self): ...
    def logq_norm(self): ...
    def _sized_symbolic_varlogp_and_datalogp(self): ...
    def sized_symbolic_varlogp(self): ...
    def sized_symbolic_datalogp(self): ...
    def sized_symbolic_logp(self): ...
    def logp(self): ...
    def varlogp(self): ...
    def datalogp(self): ...
    def _single_symbolic_varlogp_and_datalogp(self): ...
    def single_symbolic_varlogp(self): ...
    def single_symbolic_datalogp(self): ...
    def single_symbolic_logp(self): ...
    def logp_norm(self): ...
    def varlogp_norm(self): ...
    def datalogp_norm(self): ...
    @property
    def replacements(self): ...
    def make_size_and_deterministic_replacements(self, s: Any, d: Any, more_replacements: Optional[Any] = ...): ...
    def set_size_and_deterministic(self, node: Any, s: Any, d: Any, more_replacements: Optional[Any] = ...): ...
    def to_flat_input(self, node: Any): ...
    def symbolic_sample_over_posterior(self, node: Any): ...
    def symbolic_single_sample(self, node: Any): ...
    def get_optimization_replacements(self, s: Any, d: Any): ...
    def sample_node(self, node: Any, size: Optional[Any] = ..., deterministic: bool = ..., more_replacements: Optional[Any] = ...): ...
    def rslice(self, name: Any): ...
    @property
    def sample_dict_fn(self): ...
    def sample(self, draws: int = ..., include_transformed: bool = ...): ...
    @property
    def ndim(self): ...
    @property
    def ddim(self): ...
    @property
    def has_local(self): ...
    @property
    def has_global(self): ...
    @property
    def has_batched(self): ...
    def symbolic_random(self): ...
    def __str__(self): ...
    @property
    def all_histograms(self): ...
    @property
    def any_histograms(self): ...
    def joint_histogram(self): ...
    @property
    def params(self): ...
