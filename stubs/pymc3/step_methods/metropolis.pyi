# Stubs for pymc3.step_methods.metropolis (Python 3.7)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from .arraystep import ArrayStep, ArrayStepShared, PopulationArrayStepShared
from typing import Any, Optional

class Proposal:
    s: Any = ...
    def __init__(self, s: Any) -> None: ...

class NormalProposal(Proposal):
    def __call__(self): ...

class UniformProposal(Proposal):
    def __call__(self): ...

class CauchyProposal(Proposal):
    def __call__(self): ...

class LaplaceProposal(Proposal):
    def __call__(self): ...

class PoissonProposal(Proposal):
    def __call__(self): ...

class MultivariateNormalProposal(Proposal):
    n: Any = ...
    chol: Any = ...
    def __init__(self, s: Any) -> None: ...
    def __call__(self, num_draws: Optional[Any] = ...): ...

class Metropolis(ArrayStepShared):
    name: str = ...
    default_blocked: bool = ...
    generates_stats: bool = ...
    stats_dtypes: Any = ...
    proposal_dist: Any = ...
    scaling: Any = ...
    tune: Any = ...
    tune_interval: Any = ...
    steps_until_tune: Any = ...
    accepted: int = ...
    discrete: Any = ...
    any_discrete: Any = ...
    all_discrete: Any = ...
    mode: Any = ...
    delta_logp: Any = ...
    def __init__(self, vars: Optional[Any] = ..., S: Optional[Any] = ..., proposal_dist: Optional[Any] = ..., scaling: float = ..., tune: bool = ..., tune_interval: int = ..., model: Optional[Any] = ..., mode: Optional[Any] = ..., **kwargs: Any) -> None: ...
    def astep(self, q0: Any): ...
    @staticmethod
    def competence(var: Any, has_grad: Any): ...

class BinaryMetropolis(ArrayStep):
    name: str = ...
    generates_stats: bool = ...
    stats_dtypes: Any = ...
    scaling: Any = ...
    tune: Any = ...
    tune_interval: Any = ...
    steps_until_tune: Any = ...
    accepted: int = ...
    def __init__(self, vars: Any, scaling: float = ..., tune: bool = ..., tune_interval: int = ..., model: Optional[Any] = ...) -> None: ...
    def astep(self, q0: Any, logp: Any): ...
    @staticmethod
    def competence(var: Any): ...

class BinaryGibbsMetropolis(ArrayStep):
    name: str = ...
    transit_p: Any = ...
    dim: Any = ...
    shuffle_dims: bool = ...
    order: Any = ...
    def __init__(self, vars: Any, order: str = ..., transit_p: float = ..., model: Optional[Any] = ...) -> None: ...
    def astep(self, q0: Any, logp: Any): ...
    @staticmethod
    def competence(var: Any): ...

class CategoricalGibbsMetropolis(ArrayStep):
    name: str = ...
    shuffle_dims: bool = ...
    dimcats: Any = ...
    astep: Any = ...
    def __init__(self, vars: Any, proposal: str = ..., order: str = ..., model: Optional[Any] = ...) -> None: ...
    def astep_unif(self, q0: Any, logp: Any): ...
    def astep_prop(self, q0: Any, logp: Any): ...
    def metropolis_proportional(self, q: Any, logp: Any, logp_curr: Any, dim: Any, k: Any): ...
    @staticmethod
    def competence(var: Any): ...

class DEMetropolis(PopulationArrayStepShared):
    name: str = ...
    default_blocked: bool = ...
    generates_stats: bool = ...
    stats_dtypes: Any = ...
    proposal_dist: Any = ...
    scaling: Any = ...
    lamb: Any = ...
    tune: Any = ...
    tune_interval: Any = ...
    steps_until_tune: Any = ...
    accepted: int = ...
    mode: Any = ...
    delta_logp: Any = ...
    def __init__(self, vars: Optional[Any] = ..., S: Optional[Any] = ..., proposal_dist: Optional[Any] = ..., lamb: Optional[Any] = ..., scaling: float = ..., tune: bool = ..., tune_interval: int = ..., model: Optional[Any] = ..., mode: Optional[Any] = ..., **kwargs: Any) -> None: ...
    def astep(self, q0: Any): ...
    @staticmethod
    def competence(var: Any, has_grad: Any): ...
